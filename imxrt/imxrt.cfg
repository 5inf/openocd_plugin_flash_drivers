if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME imx1050
}

source [find mem_helper.tcl]

# SBMR2: Bit 25..24:
# BOOT_MODE[1:0]: 00b - Boot From Fuses
#                 01b - Serial Downloader
#                 10b - Internal Boot
#                 11b - Reserved
proc get_boot_mode {} {
	set SRC_SBMR2 [ mrw 0x400F801C ]
	set bootmode [expr ($SRC_SBMR2 & 0x03000000) >> 24 ]
	return $bootmode
}

# Boot Device: 0000b - Serial NOR boot via FlexSPI
#              001xb - SD boot via uSDHC
#              10xxb - eMMC/MMC boot via uSDHC
#              01xxb - SLC NAND boot via SEMC
#              0001b - Parallel NOR boot via SEMC
#              11xxb - Serial NAND boot via FlexSPI
proc get_boot_device {} {
	set SRC_SBMR1 [ mrw 0x400F8004 ]
	set bootdevice [expr ($SRC_SBMR1 & 0x000000F0) >> 4 ]
	return $bootdevice
}

proc get_reset_vector {} {
	global FLASH_MEMORY_BASE
	set MAX_FLASH_MEMORY_SIZE 0x10000000
	
	set vector_table_addr [ mrw [expr $FLASH_MEMORY_BASE + 0x1004 ] ]
	if { ($vector_table_addr < $FLASH_MEMORY_BASE) || ($vector_table_addr > ($FLASH_MEMORY_BASE + $MAX_FLASH_MEMORY_SIZE)) } {
		return 0
	}
	
	set reset_vector [ mrw [expr $vector_table_addr + 4] ]
	return $reset_vector
}

#The regular "reset halt" command on i.MXRT will stop the chip at the internal entry point in the boot ROM.
#At this point the internal bootloader has not initialized the peripherals set.
#Running "reset_into_entry" instead of "reset halt" will reset the chip into the entry point in the regular FLASH memory, but only if a valid program is present there.
proc reset_into_entry {} {
	set bootmode [ get_boot_mode ]
	set bootdev [ get_boot_device ]
	
	if { $bootmode != 2 } {
		echo "Cannot reset into entry when boot mode is $bootmode"
		return
	}
	
	if { $bootdev != 0 } {
		echo "Cannot reset into entry when boot device is $bootdev"
		return
	}
	
	set entry_point [ get_reset_vector ]
	
	if { $entry_point == 0 } {
		echo "Cannot locate the reset vector in FLASH memory. Make sure FLASH is initialized."
		return
	}
	
	set entry_point_hex [ format "0x%X" $entry_point ]
	echo "Found entry point at $entry_point_hex. Setting a temporary breakpoint and resetting..."
	bp $entry_point 2 hw
	
	reset run
	wait_halt 1000
	rbp $entry_point
}

set FLASH_MEMORY_BASE 0x60000000


#
# Only SWD and SPD supported
#
source [find target/swj-dp.tcl]

if { [info exists CPUTAPID] } {
	set _CPU_SWD_TAPID $CPUTAPID
} else {
	set _CPU_SWD_TAPID 0x0BD11477
}

swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPU_SWD_TAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian little -dap $_CHIPNAME.dap

if { [info exists WORKAREASIZE] } {
   set _WORKAREASIZE $WORKAREASIZE
} else {
   set _WORKAREASIZE 0x4000
}

$_TARGETNAME configure -work-area-phys 0x20200000 \
                       -work-area-size $_WORKAREASIZE \
                       -work-area-backup 0

#Using SRST on i.MXRT devices will not get the chip to halt. Doing a system reset on the ARM Cortex level instead works as expected
cortex_m reset_config sysresetreq
reset_config none

#flash bank qspi plugin $FLASH_MEMORY_BASE 0 0 0 0 C:/projects/QSPIDriver/Debug/QSPIDriver.elf
